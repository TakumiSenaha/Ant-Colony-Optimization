# 失敗の扱いに関する明確化

## 1. 全部失敗なら失敗か？

### 答え: **はい、全部失敗なら失敗です**

### 現在の定義

**成功率の定義**: 「1 世代で 10 匹のアリのうち、少なくとも 1 匹が成功すれば、その世代は成功」

### 具体例

#### ケース 1: 全部失敗

```
1世代の10匹のアリの結果:
CSVファイルに記録される値: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
                              ↑ すべて失敗

分析結果:
- `any(idx >= 0 for idx in generation_chunk)` → False
- この世代は「失敗」としてカウントされる
- generation_success_count に加算されない
```

#### ケース 2: 1 匹でも成功

```
1世代の10匹のアリの結果:
CSVファイルに記録される値: [-1, -1, -1, 0, -1, -1, -1, -1, -1, -1]
                              ↑ 4匹目が成功、他は失敗

分析結果:
- `any(idx >= 0 for idx in generation_chunk)` → True
- この世代は「成功」としてカウントされる
- generation_success_count に加算される
```

### 結論

- **全部失敗（10 匹すべてが-1）**: その世代は「失敗」としてカウントされる
- **1 匹でも成功（10 匹中 1 匹以上が 0）**: その世代は「成功」としてカウントされる

---

## 2. 失敗の種類と同義性

### 答え: **はい、すべての失敗は同義として扱われます**

### 失敗の種類

すべての失敗は、**同じログ値 `-1`** として記録されます：

1. **TTL 到達（生存時間超過）**

   - コード: `aco_solver.py` 511-512 行目
   - ログ値: `-1`
   - コメント: `# -1 = ゴール未到達`

2. **ループ/デッドエンド（行き先がない）**

   - コード: `aco_solver.py` 524-525 行目
   - ログ値: `-1`
   - コメント: `# -1 = ゴール未到達`

3. **遅延制約違反（移動前）**

   - コード: `aco_solver.py` 540-545 行目
   - ログ値: `-1`
   - コメント: `# -1 = ゴール未到達（制約違反）`

4. **遅延制約違反（ゴール到達時）**
   - コード: `aco_solver.py` 567-572 行目
   - ログ値: `-1`
   - コメント: `# -1 = ゴール未到達（制約違反）`

### 分析での扱い

**すべての失敗は区別されません**：

```python
# compare_delay_constraint_proposed.py 336行目
if any(idx >= 0 for idx in generation_chunk):
    generation_success_count += 1
```

- **成功**: `idx >= 0` → カウントされる
- **失敗**: `idx < 0`（すべて `-1`） → **区別されず、すべて同じように扱われる**

### 結論

- **TTL 到達による失敗** = `-1`
- **ループ/デッドエンドによる失敗** = `-1`
- **遅延制約違反による失敗** = `-1`

**すべての失敗は同義として扱われます**。分析では、失敗の原因（TTL、ループ、制約違反）は区別されません。

---

## 3. まとめ

### 3.1 全部失敗なら失敗か？

**はい、全部失敗なら失敗です。**

- 1 世代で 10 匹のアリがすべて失敗（すべて `-1`）の場合、その世代は「失敗」としてカウントされます
- 成功率の計算では、その世代は成功したシミュレーション数に含まれません

### 3.2 失敗の種類と同義性

**はい、すべての失敗は同義として扱われます。**

- TTL 到達、ループ/デッドエンド、遅延制約違反など、すべての失敗は同じログ値 `-1` として記録されます
- 分析では、失敗の原因は区別されず、すべて同じように扱われます
- つまり、「遅延制約による失敗」と「TTL 到達による失敗」は、分析の観点からは**同義**です

### 3.3 実装上の意味

この設計により：

1. **シンプルな分析**: 失敗の原因を区別する必要がなく、分析が簡潔になります
2. **統一的な扱い**: すべての失敗を同じように扱うことで、成功率の定義が明確になります
3. **柔軟性**: 将来的に失敗の種類を区別したい場合は、ログ値を変更（`-1`, `-2`, `-3`など）することで対応可能です

---

## 4. 将来の改善案（オプション）

もし失敗の種類を区別して分析したい場合は、以下のような改善が考えられます：

### 4.1 ログ値の拡張

```python
# 現在
-1: すべての失敗（TTL、ループ、制約違反）

# 改善案
-1: TTL到達
-2: ループ/デッドエンド
-3: 遅延制約違反（移動前）
-4: 遅延制約違反（ゴール到達時）
```

### 4.2 分析の拡張

```python
# 失敗率の分析
failure_rate_ttl = count(-1) / total_ants
failure_rate_loop = count(-2) / total_ants
failure_rate_constraint = (count(-3) + count(-4)) / total_ants
```

ただし、現在の実装では、すべての失敗は `-1` として記録され、分析では区別されません。








