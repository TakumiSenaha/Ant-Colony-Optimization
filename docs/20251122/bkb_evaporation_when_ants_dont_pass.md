# アリが通らない期間の BKB 値の挙動

## ユーザーの質問

1. **「蟻が通らない期間、リングバッファ 10 の BKB 値はどうなっているのですか？」**
2. **「蟻が通らない期間、どうやって、どれだけ揮発したのかを管理するのか？BKB 値は別で管理しないと？」**

---

## 現在の実装の動作

### データ構造

```python
# ノードに保存されるデータ
graph.nodes[node]["time_window_values"] = [観測値1, 観測値2, ..., 観測値10]  # リングバッファ（生の観測値）
graph.nodes[node]["best_known_bottleneck"] = 100  # BKB値（別管理）
```

### アリが通る場合

```python
# update_node_bkb_time_window_max() が呼ばれる
window_values.append(bottleneck)  # 新しい観測値を追加
time_window_max = max(window_values)  # バッファ内のmax値を計算
graph.nodes[node]["best_known_bottleneck"] = int(time_window_max)  # BKB値を更新（上書き）
```

### アリが通らない場合

```python
# update_node_bkb_time_window_max() は呼ばれない
# リングバッファは更新されない（古い観測値が残る）
# BKB値は揮発される
```

---

## アリが通らない期間の詳細な挙動

### シナリオ: ノード X をアリが通らない

```
世代N: 最後にアリがノードXを通った
       → window_values = [100, 90, 95, 100, 85, 90, 100, 95, 90, 100]
       → BKB = max(window_values) = 100
       → 揮発後: BKB = 100 × 0.999 = 99.9

世代N+1: アリがノードXを通らない
         → update_node_bkb_time_window_max() は呼ばれない
         → window_values = [100, 90, 95, 100, 85, 90, 100, 95, 90, 100]（変わらず）
         → BKB = 99.9（前世代の揮発後の値）
         → フェロモン揮発時: BKB = 99.9 が参照される
         → 揮発後: BKB = 99.9 × 0.999 = 99.8

世代N+2: アリがノードXを通らない
         → window_values = [100, 90, 95, 100, 85, 90, 100, 95, 90, 100]（変わらず）
         → BKB = 99.8
         → 揮発後: BKB = 99.8 × 0.999 = 99.7

...

世代N+100: アリがノードXを通らない
           → window_values = [100, 90, 95, 100, 85, 90, 100, 95, 90, 100]（変わらず）
           → BKB ≈ 100 × 0.999^100 ≈ 90.5
           → 揮発後: BKB ≈ 90.5 × 0.999 ≈ 90.4

世代N+101: アリがノードXを通る
           → update_node_bkb_time_window_max() が呼ばれる
           → 新しい観測値（例: 80）を追加
           → window_values = [90, 95, 100, 85, 90, 100, 95, 90, 100, 80]（FIFOで1つ削除）
           → time_window_max = max(window_values) = 100
           → BKB = 100（元に戻る）
           → 揮発の効果が消える
```

---

## 重要なポイント

### 1. リングバッファと BKB 値は別管理

- **リングバッファ** (`time_window_values`): 生の観測値を保存（揮発されない）
- **BKB 値** (`best_known_bottleneck`): 別で管理され、揮発される

### 2. アリが通らない期間の動作

- **リングバッファ**: 更新されない（古い観測値が残る）
- **BKB 値**: 揮発し続ける（0.999 を毎世代かける）

### 3. アリが通った瞬間

- **リングバッファ**: 新しい観測値を追加（FIFO で古いものを削除）
- **BKB 値**: `max(window_values)` で上書き（揮発の効果が消える）

---

## ユーザーの指摘に対する回答

### Q1: 「蟻が通らない期間、リングバッファ 10 の BKB 値はどうなっているのですか？」

**A:**

- **リングバッファ** (`time_window_values`): 古い観測値がそのまま残る（更新されない）
- **BKB 値** (`best_known_bottleneck`): 毎世代 0.999 をかけて揮発し続ける

**例:**

```
世代N: BKB = 100
世代N+100: リングバッファ = [100, 90, ...]（変わらず）
           BKB ≈ 90.5（揮発）
```

### Q2: 「蟻が通らない期間、どうやって、どれだけ揮発したのかを管理するのか？BKB 値は別で管理しないと？」

**A: はい、その通りです！**

現在の実装では、**BKB 値は別で管理されています**：

```python
# リングバッファ（観測値の保存）
graph.nodes[node]["time_window_values"] = [観測値1, ..., 観測値10]

# BKB値（別管理、揮発される）
graph.nodes[node]["best_known_bottleneck"] = 100
```

**揮発の管理:**

- アリが通らない期間、`best_known_bottleneck` に毎世代 0.999 をかける
- これにより、揮発した分が記録される
- アリが通った瞬間、`max(window_values)` で上書きされる

---

## 問題点の再確認

### 現在の実装の問題

1. **アリが通らない期間**: BKB 値は揮発する ✅
2. **アリが通った瞬間**: BKB 値が `max(window_values)` で上書きされる ❌
   - 揮発の効果が即座に消える
   - リングバッファ内の古い高い値がそのまま反映される

### ユーザーの指摘の妥当性

**「アリが通らない期間のみ一時的に効果がありますが、次の世代にアリが通ると即座に元に戻ります」**

→ **これは正しいです！**

しかし、ユーザーの次の指摘も重要です：

**「これには BKB 値は別で管理しないと、蟻が通らない期間どうやって、どれだけ揮発したのかを管理するのか？」**

→ **これは正しいです！BKB 値は別で管理されていて、揮発は管理されています。**

**ただし、問題は「アリが通った瞬間に上書きされる」ことです。**

---

## まとめ

1. **BKB 値は別で管理されている** ✅
2. **アリが通らない期間、BKB 値は揮発し続ける** ✅
3. **しかし、アリが通った瞬間、`max(window_values)` で上書きされる** ❌
4. **したがって、揮発の効果は一時的なもの** ❌

**解決策:**

- リングバッファ内の値に揮発を適用する
- または、BKB 値を上書きする際に揮発後の値も考慮する
- または、BKB 揮発を削除して FIFO のみに依存する



