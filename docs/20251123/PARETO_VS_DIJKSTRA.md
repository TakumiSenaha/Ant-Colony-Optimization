# ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ vs Modified Dijkstra

## ğŸ“Š æ¯”è¼ƒçµæœ

**çµè«–**: å¸¯åŸŸã®ã¿ã‚’æœ€é©åŒ–ã™ã‚‹å ´åˆã€**æœ€å¤§å¸¯åŸŸã®å€¤ã¨çµŒè·¯ã¯åŒã˜**ã«ãªã‚Šã¾ã™ã€‚

ãŸã ã—ã€ä»¥ä¸‹ã®é‡è¦ãªé•ã„ãŒã‚ã‚Šã¾ã™ï¼š

## ğŸ” ä¸»ãªé•ã„

### Modified Dijkstra (`src/modified_dijkstra.py`)

- **ç›®çš„**: å˜ä¸€ç›®çš„ï¼ˆãƒœãƒˆãƒ«ãƒãƒƒã‚¯å¸¯åŸŸã®æœ€å¤§åŒ–ã®ã¿ï¼‰
- **è¿”ã‚Šå€¤**: å˜ä¸€ã®æœ€é©è§£ï¼ˆæœ€å¤§å¸¯åŸŸã®çµŒè·¯ 1 ã¤ï¼‰
- **ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **:
  - å„ãƒãƒ¼ãƒ‰ã« 1 ã¤ã®æœ€è‰¯å€¤ï¼ˆbottleneckï¼‰ã‚’ä¿æŒ
  - å„ªå…ˆåº¦ã‚­ãƒ¥ãƒ¼ã§æœ€å¤§ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã‚’æŒã¤ãƒãƒ¼ãƒ‰ã‚’é¸æŠ
  - `new_bottleneck = min(current_bottleneck, edge_bandwidth)`
  - ã‚ˆã‚Šå¤§ãã„ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ãŒè¦‹ã¤ã‹ã£ãŸã‚‰æ›´æ–°

### ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ (`aco_moo_routing/src/aco_routing/algorithms/pareto_solver.py`)

- **ç›®çš„**: å¤šç›®çš„ï¼ˆå¸¯åŸŸã€é…å»¶ã€ãƒ›ãƒƒãƒ—æ•°ï¼‰
- **è¿”ã‚Šå€¤**: ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®ãƒªã‚¹ãƒˆï¼ˆè¤‡æ•°ã®è§£ãŒè¿”ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰
- **ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **:
  - å„ãƒãƒ¼ãƒ‰ã«è¤‡æ•°ã®ãƒ©ãƒ™ãƒ«ï¼ˆéæ”¯é…è§£ã®ãƒªã‚¹ãƒˆï¼‰ã‚’ä¿æŒ
  - å„ªå…ˆåº¦ã‚­ãƒ¥ãƒ¼ã§æœ€å¤§å¸¯åŸŸã‚’æŒã¤ãƒ©ãƒ™ãƒ«ã‚’é¸æŠ
  - `new_label = (min(current_bandwidth, edge_bandwidth), current_delay + edge_delay, current_hops + 1)`
  - æ”¯é…é–¢ä¿‚ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°

## âœ… åŒã˜ç‚¹

### å¸¯åŸŸã®ã¿ã‚’æœ€é©åŒ–ã™ã‚‹å ´åˆ

1. **æœ€å¤§å¸¯åŸŸã®å€¤**: åŒã˜
2. **æœ€å¤§å¸¯åŸŸã®çµŒè·¯**: åŒã˜ï¼ˆãƒãƒ¼ãƒ‰ã®é›†åˆã¨ã—ã¦ï¼‰

### ãƒ†ã‚¹ãƒˆçµæœ

```bash
$ python tests/test_pareto_vs_dijkstra.py
âœ… å¸¯åŸŸã®ã¿æœ€é©åŒ–ã®å ´åˆã€åŒã˜çµæœã‚’è¿”ã™ã“ã¨ã‚’ç¢ºèª
âœ… All tests passed!
```

## âš ï¸ é‡è¦ãªé•ã„

### ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã®ç‰¹å¾´

å¸¯åŸŸã®ã¿ã‚’æœ€é©åŒ–ã™ã‚‹å ´åˆã§ã‚‚ã€ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã¯**å¤šç›®çš„æœ€é©åŒ–ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**ã§å‹•ä½œã™ã‚‹ãŸã‚ï¼š

1. **è¤‡æ•°ã®è§£ã‚’è¿”ã™å¯èƒ½æ€§**: åŒã˜å¸¯åŸŸã§ã‚‚ç•°ãªã‚‹é…å»¶/ãƒ›ãƒƒãƒ—æ•°ã®çµŒè·¯ãŒè¤‡æ•°ã‚ã‚‹å ´åˆã€ãã‚Œã‚‰ã™ã¹ã¦ãŒãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã¨ã—ã¦è¿”ã•ã‚Œã‚‹
2. **é…å»¶ã¨ãƒ›ãƒƒãƒ—æ•°ã‚‚è¨˜éŒ²**: å„è§£ã«ã¯å¸¯åŸŸã ã‘ã§ãªãã€é…å»¶ã¨ãƒ›ãƒƒãƒ—æ•°ã‚‚å«ã¾ã‚Œã‚‹
3. **æ”¯é…é–¢ä¿‚ã®åˆ¤å®š**: å¸¯åŸŸãŒåŒã˜ã§ã‚‚ã€é…å»¶ã‚„ãƒ›ãƒƒãƒ—æ•°ãŒç•°ãªã‚‹çµŒè·¯ã¯äº’ã„ã«æ”¯é…ã—ãªã„ãŸã‚ã€ã™ã¹ã¦ä¿æŒã•ã‚Œã‚‹

### ä¾‹

åŒã˜æœ€å¤§å¸¯åŸŸ 80 ã®çµŒè·¯ãŒ 2 ã¤ã‚ã‚‹å ´åˆï¼š

- **Modified Dijkstra**: 1 ã¤ã®çµŒè·¯ã®ã¿è¿”ã™ï¼ˆæœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚‚ã®ã€ã¾ãŸã¯ä»»æ„ã® 1 ã¤ï¼‰
- **ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼**: ä¸¡æ–¹ã®çµŒè·¯ã‚’è¿”ã™
  - çµŒè·¯ 1: `(bandwidth=80, delay=8, hops=2, path=[0,1,2])`
  - çµŒè·¯ 2: `(bandwidth=80, delay=10, hops=3, path=[0,3,4,2])`

## ğŸ“ å®Ÿè£…ã®è©³ç´°

### Modified Dijkstra ã®æ ¸å¿ƒ

```python
# å„ãƒãƒ¼ãƒ‰ã«1ã¤ã®æœ€è‰¯å€¤ã®ã¿ä¿æŒ
bottleneck = {node: float("-inf") for node in G}
bottleneck[source] = float("inf")

# æ›´æ–°æ¡ä»¶: ã‚ˆã‚Šå¤§ãã„ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ãŒè¦‹ã¤ã‹ã£ãŸã‚‰æ›´æ–°
if new_bottle > bottleneck[v]:
    bottleneck[v] = new_bottle
    pred[v] = u
```

### ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã®æ ¸å¿ƒ

```python
# å„ãƒãƒ¼ãƒ‰ã«è¤‡æ•°ã®ãƒ©ãƒ™ãƒ«ï¼ˆéæ”¯é…è§£ï¼‰ã‚’ä¿æŒ
labels: Dict[int, List[Label]] = {node: [] for node in graph.nodes()}

# æ”¯é…é–¢ä¿‚ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
dominated = new_label.is_dominated_by_any(labels[neighbor])
if dominated:
    continue  # ç ´æ£„

# æ–°ã—ã„ãƒ©ãƒ™ãƒ«ãŒæ—¢å­˜ãƒ©ãƒ™ãƒ«ã‚’æ”¯é…ã™ã‚‹å ´åˆã€æ—¢å­˜ãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
labels[neighbor] = [
    label for label in labels[neighbor]
    if not new_label.dominates(label)
]
```

## ğŸ¯ ä½¿ç”¨ä¸Šã®æ³¨æ„

### å¸¯åŸŸã®ã¿ã‚’æœ€é©åŒ–ã™ã‚‹å ´åˆ

1. **æœ€å¤§å¸¯åŸŸã®è§£ã‚’å–å¾—**: ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ã‹ã‚‰æœ€å¤§å¸¯åŸŸã®è§£ã‚’é¸æŠ

   ```python
   max_bandwidth_solution = max(pareto_frontier, key=lambda x: x[0])
   ```

2. **å˜ä¸€è§£ãŒå¿…è¦ãªå ´åˆ**: Modified Dijkstra ã‚’ä½¿ç”¨ã™ã‚‹æ–¹ãŒåŠ¹ç‡çš„

   - è¨ˆç®—é‡: O(E log V) vs O(E _ L _ log V)ï¼ˆL ã¯ãƒ©ãƒ™ãƒ«æ•°ï¼‰
   - ãƒ¡ãƒ¢ãƒª: O(V) vs O(V \* L)

3. **å¤šç›®çš„æœ€é©åŒ–ã®å ´åˆ**: ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã‚’ä½¿ç”¨
   - å¸¯åŸŸã€é…å»¶ã€ãƒ›ãƒƒãƒ—æ•°ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã‚’è€ƒæ…®
   - è¤‡æ•°ã®æœ€é©è§£ã‚’å–å¾—å¯èƒ½

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ

| é …ç›®           | Modified Dijkstra | ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼               |
| -------------- | ----------------- | ------------------------------ |
| ç›®çš„é–¢æ•°       | å˜ä¸€ï¼ˆå¸¯åŸŸã®ã¿ï¼‰  | å¤šç›®çš„ï¼ˆå¸¯åŸŸã€é…å»¶ã€ãƒ›ãƒƒãƒ—æ•°ï¼‰ |
| è¿”ã‚Šå€¤         | å˜ä¸€ã®è§£          | ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®ãƒªã‚¹ãƒˆ         |
| è¨ˆç®—é‡         | O(E log V)        | O(E _ L _ log V)               |
| ãƒ¡ãƒ¢ãƒª         | O(V)              | O(V \* L)                      |
| å¸¯åŸŸã®ã¿æœ€é©åŒ– | âœ… æœ€é©           | âš ï¸ éå‰°ï¼ˆå¤šç›®çš„ç”¨ï¼‰            |

**L**: å„ãƒãƒ¼ãƒ‰ã§ä¿æŒã™ã‚‹ãƒ©ãƒ™ãƒ«æ•°ã®å¹³å‡

## ğŸ”¬ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰

`tests/test_pareto_vs_dijkstra.py`ã§æ¯”è¼ƒãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…æ¸ˆã¿ã€‚

```python
def test_bandwidth_only_optimization():
    """å¸¯åŸŸã®ã¿ã‚’æœ€é©åŒ–ã™ã‚‹å ´åˆã€åŒã˜çµæœã‚’è¿”ã™ã‹ãƒ†ã‚¹ãƒˆ"""
    # Modified Dijkstraã§è¨ˆç®—
    dijkstra_path, dijkstra_bottleneck = max_load_path_simple(...)

    # ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã§è¨ˆç®—
    pareto_frontier = pareto_solver.find_pareto_frontier(...)
    max_bandwidth_solution = max(pareto_frontier, key=lambda x: x[0])

    # æœ€å¤§å¸¯åŸŸã¨çµŒè·¯ãŒåŒã˜ã‹ç¢ºèª
    assert abs(dijkstra_bottleneck - pareto_bottleneck) < 0.01
    assert set(dijkstra_path) == set(pareto_path)
```

## âœ… çµè«–

**å¸¯åŸŸã®ã¿ã‚’æœ€é©åŒ–ã™ã‚‹å ´åˆ**:

- âœ… **æœ€å¤§å¸¯åŸŸã®å€¤**: åŒã˜
- âœ… **æœ€å¤§å¸¯åŸŸã®çµŒè·¯**: åŒã˜ï¼ˆãƒãƒ¼ãƒ‰ã®é›†åˆã¨ã—ã¦ï¼‰
- âš ï¸ **è¿”ã‚Šå€¤ã®å½¢å¼**: ç•°ãªã‚‹ï¼ˆå˜ä¸€è§£ vs ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®ãƒªã‚¹ãƒˆï¼‰
- âš ï¸ **è¨ˆç®—ã‚³ã‚¹ãƒˆ**: ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã®æ–¹ãŒé«˜ã„ï¼ˆå¤šç›®çš„æœ€é©åŒ–ã®ãŸã‚ï¼‰

**æ¨å¥¨**:

- å¸¯åŸŸã®ã¿æœ€é©åŒ–: Modified Dijkstra ã‚’ä½¿ç”¨ï¼ˆåŠ¹ç‡çš„ï¼‰
- å¤šç›®çš„æœ€é©åŒ–: ãƒ‘ãƒ¬ãƒ¼ãƒˆã‚½ãƒ«ãƒãƒ¼ã‚’ä½¿ç”¨ï¼ˆå¸¯åŸŸã€é…å»¶ã€ãƒ›ãƒƒãƒ—æ•°ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã‚’è€ƒæ…®ï¼‰
