# ACS (Ant Colony System) アルゴリズムリファレンス

## 目的
従来手法（Conventional Method）の実装が、Dorigo & Gambardella (1997)のACSアルゴリズムを
MBL問題に**単純に適用しただけ**になっているかを検証するための参照資料。

---

## 1. ACS の基本メカニズム（TSP向けオリジナル）

### 出典
Dorigo, M., & Gambardella, L. M. (1997).  
"Ant Colony System: A Cooperative Learning Approach to the Traveling Salesman Problem"  
IEEE Transactions on Evolutionary Computation, Vol. 1, No. 1, pp. 53-66.

---

### 1.1 状態遷移規則 (State Transition Rule)

**〜 蟻が「次どこに行く？」を決めるルール 〜**

ACSの最大の特徴は、**「確率（ルーレット）」だけでなく「確実な選択」を混ぜる**点です。  
これを制御するのがパラメータ **q₀** です。

蟻 k が今いるノード i から、次のノード j を選ぶ際、まず [0,1] の乱数 q を振ります。

#### **ケースA： q ≤ q₀ の場合（Exploitation: 知識の利用）**

「冒険はしない。今わかっている一番いい道を行く」モードです。  
以下が最大になるノード j を**確定的**に選びます。

```
j = argmax_l { [τ_il]^α · [η_il]^β }
```

* `τ_ij`: フェロモン（みんなが良いと言っている度合い）
* `η_ij`: ヒューリスティック情報（局所的な道の良さ。TSPなら距離の逆数 `1/d_ij`）
* `α, β`: フェロモンとヒューリスティックの重み（論文推奨: α=1, β=2）

#### **ケースB： q > q₀ の場合（Biased Exploration: 偏りのある探索）**

「ちょっと冒険してみるか」モードです。  
従来のAnt Systemと同じく、以下の確率分布に従って**確率的**に選びます（ルーレット選択）。

```
p_ij^k = [τ_ij]^α · [η_ij]^β / Σ_l [τ_il]^α · [η_il]^β
```

> **解説:**  
> q₀ = 0.9（論文推奨値）という高い確率で「現時点のベスト」を選び続けるため、ACSは収束が早いです。  
> しかし、それだけだとすぐに局所解に陥るため、たまに (1-q₀=0.1) 確率的な揺らぎを許容します。

**論文推奨値:**
* q₀ = 0.9
* α = 1.0
* β = 2.0

---

### 1.2 局所的更新規則 (Local Updating Rule)

**〜 通った直後に道を「荒らす」ルール 〜**

これはACS独自の非常に面白い仕組みです。  
蟻が一歩進んでエッジ (i, j) を通った**その瞬間に**、そのエッジのフェロモンを**減らします**。

```
τ_ij ← (1-ξ)τ_ij + ξτ₀
```

* `ξ`: 局所的な蒸発率（論文推奨: ξ = 0.1）
* `τ₀`: フェロモンの初期値（論文: τ₀ = 1/(n·L_nn)、n=ノード数、L_nn=最近傍解の長さ）

> **解説:**  
> なぜ減らすのか？  
> 「私がここを通ったから、後続の蟻は**あえて別の道**を探してね」という合図です。  
> これにより、同じイテレーション内の蟻たちが一斉に同じルート（一本道）に殺到するのを防ぎ、  
> 強制的に**探索の多様性（Shuffle効果）**を生み出します。  
> これがないと、q₀=0.9 の強力な収束力によって、全員が同じ解にすぐ収束してしまいます。

**論文推奨値:**
* ξ = 0.1
* τ₀ = 1/(n·L_nn) （TSPの場合）

---

### 1.3 大域的更新規則 (Global Updating Rule)

**〜 チャンピオンだけが許される発言権 〜**

すべての蟻がゴールに到達（1イテレーション終了）した後に行う更新です。  
ACSでは、**「これまでに見つかった最高の経路（Global Best）」**を通ったエッジに対してのみ、フェロモンを追加します。  
※他の普通の蟻はフェロモンを残せません。

**手順:**

1. **全エッジの蒸発:**
```
τ_ij ← (1-ρ)τ_ij  （全エッジ）
```

2. **Global Bestの経路にのみ付加:**
```
τ_ij ← τ_ij + ρ·Δτ_ij  （Global Bestの経路に属するエッジのみ）
```

TSPの場合:
```
Δτ_ij = 1/L_gb
```
* `L_gb`: Global Best経路の総長（短いほど良い → 逆数で報酬）

> **解説:**  
> 「一番上手くいった成功体験」だけを強烈に強化します。  
> 局所更新（1.2）で「多様な探索」を担保しているので、大域更新では「収束」に全振りする、というバランスの取り方です。

**論文推奨値:**
* ρ = 0.1

---

### 1.4 ACSアルゴリズムの全体像まとめ

1. **初期化:** 全エッジに τ₀ をセット。
2. **ループ開始:**
3. **各蟻の移動:**
   * q₀ の確率で「一番いい道」へ、それ以外は「ルーレット」で移動。
   * **移動直後:** 通った道のフェロモンを**減らす**（局所更新）。
4. **全蟻ゴール:** 全員が経路を作り終える。
5. **エリート教育:** 今までの**最良経路（Global Best）**のエッジだけ、フェロモンを**増やす**（大域更新）。
6. **2に戻る:** 満足するまで繰り返す。

---

## 2. MBL問題への適用方法の検討

### 2.1 TSPとMBLの根本的な違い

| 項目 | TSP | MBL (Maximum Bottleneck Load) |
|------|-----|-------------------------------|
| **目的** | 総距離を最小化 | ボトルネック帯域を最大化 |
| **最適化方向** | Minimize | Maximize |
| **経路評価値** | Σ d_ij (総和) | min{w_ij} (最小値) |
| **ヒューリスティック** | η_ij = 1/d_ij (距離の逆数) | η_ij = w_ij (帯域幅そのもの) |
| **フェロモン付加量** | Δτ = 1/L_gb (短い経路ほど多い) | Δτ = Q·B_gb (広い帯域ほど多い?) |

### 2.2 MBL問題への正しい適用方法（理論的考察）

#### **基本方針: 最小化問題と最大化問題の対応**

TSPは「総距離を**最小化**」する問題ですが、MBL問題は「ボトルネック帯域を**最大化**」する問題です。  
この根本的な違いを考慮すると、以下のような対応関係が考えられます。

| TSP（最小化問題） | MBL問題（最大化問題） | 対応方法 |
|------------------|---------------------|---------|
| 短い距離 → 良い | 広い帯域 → 良い | そのまま |
| 総距離 = Σ d_ij | ボトルネック帯域 = min{w_ij} | 集約方法が異なる |
| L_gb が小さい → 良い | B_gb が大きい → 良い | **逆方向** |
| Δτ = 1/L_gb（逆数） | Δτ = ? | **要検討** |

#### **選択1: ヒューリスティック情報 η_ij の定義**

**TSPの場合:**
```
η_ij = 1/d_ij  （距離が短いほど良い → 逆数で大きくする）
```

**MBL問題の場合:**
```
η_ij = w_ij  （帯域が広いほど良い → そのまま使う）
```

**理由:**
- TSP: 距離は小さいほど良い → 逆数変換で「大きい方が良い」に統一
- MBL: 帯域は大きいほど良い → そのまま使える

#### **選択2: フェロモン付加量 Δτ_ij の定義**

**TSPの場合（論文オリジナル）:**
```
Δτ_ij = 1/L_gb  （Global Best経路の総距離の逆数）
```
- 短い経路ほど Δτ が大きい → 短い経路を強く強化

**MBL問題への適用（本実装）:**
```
Δτ_ij = Q · B_gb  （Global Bestのボトルネック帯域に比例）
```
- 広い帯域の経路ほど Δτ が大きい → 広い帯域の経路を強く強化

**問題点（深刻）:**

1. **最小化と最大化の非対称性**
   - TSP: L_gb が小さい → Δτ = 1/L_gb が**大きい** → 良い経路を強く強化
   - MBL: B_gb が大きい → Δτ = B_gb が**大きい** → 良い経路を強く強化
   - **一見対応しているように見えるが、スケールの問題がある**

2. **スケールの違い**
   - TSP: 総距離 L_gb = 100〜1000（複数エッジの総和） → Δτ = 0.001〜0.01
   - MBL: ボトルネック帯域 B_gb = 10〜100（**1つのエッジの値**） → Δτ = 10〜100
   - **MBLでは評価値がエッジ1本分の値なのに対し、TSPでは経路全体の総和**
   - 結果として、MBLのΔτは**1000〜10000倍大きい**

3. **正規化の必要性**
   - TSPの Δτ = 1/L_gb は自然に正規化されている（大きな値の逆数 = 小さな値）
   - MBLの Δτ = B_gb はそのまま使うと大きすぎる
   - **正規化案1:** Δτ = B_gb / W_max（最大帯域で正規化）→ 0.1〜1.0の範囲
   - **正規化案2:** Δτ = (B_gb - W_min) / (W_max - W_min)（min-maxスケーリング）→ 0〜1の範囲
   - **正規化案3:** Δτ = 1 / (W_max - B_gb + ε)（TSPと同じ形式、逆数変換）→ 小さいほど良い

4. **経路長の考慮**
   - TSPでは「総距離」なので、経路が長いほどL_gbが大きくなる
   - MBLでは「ボトルネック帯域」なので、経路の長さは無関係
   - **TSPとの対応を取るなら:** Δτ = B_gb / H_gb（ホップ数で割る）も考えられる
   - しかし、これはMBL問題の本質（ボトルネック最大化）とずれる可能性がある

#### **選択3: 初期フェロモン τ₀ の定義**

**TSPの場合（論文オリジナル）:**
```
τ₀ = 1/(n · L_nn)
```
- n: ノード数
- L_nn: 最近傍ヒューリスティック解の総距離

**MBL問題への適用（本実装で"auto"の場合）:**
```
τ₀ = B_nn / n
```
- B_nn: 最近傍ヒューリスティック解（貪欲法）のボトルネック帯域
- n: ノード数

**問題点（深刻）:**

1. **TSPの式を機械的に逆転させただけ**
   - TSP: τ₀ = 1/(n·L_nn) → 分母に n と L_nn
   - MBL: τ₀ = B_nn / n → 分子に B_nn、分母に n
   - **単純に「1/L_nn」を「B_nn」に置き換えただけで、理論的根拠が不明**

2. **τ₀の意図が失われている**
   - 論文の意図: 「控えめな初期値」を設定し、学習によって徐々に強化する
   - TSPの場合: τ₀ = 1/(n·L_nn) ≈ 0.001（非常に小さい）
   - MBL問題の計算値: τ₀ = B_nn/n = 50/100 = 0.5（小さい値）
   - **しかし実際には min_pheromone=100 で100に引き上げられる → 意図が完全に失われる**

3. **正しい τ₀ の設定方法（理論的考察）**

   **方針A: TSPの式を正しく変換する**
   ```
   TSP: τ₀ = 1 / (n · L_nn)
   
   MBL問題への変換:
   - L_nn（総距離、大きい方が悪い）→ 1/(B_nn)（帯域の逆数、小さい方が良い）
   - τ₀ = 1 / (n · (1/B_nn)) = B_nn / n
   ```
   → 計算上は本実装と同じだが、**min_pheromone=100で上書きされるので無意味**

   **方針B: スケーリングを考慮する**
   ```
   TSPのスケール: L_nn ≈ 100〜1000、n ≈ 50〜100
   → τ₀ = 1/(n·L_nn) ≈ 0.00001〜0.0002
   
   MBL問題のスケール: B_nn ≈ 10〜100、n ≈ 50〜100
   → τ₀ = B_nn/n ≈ 0.1〜2.0
   
   スケール比: MBLの τ₀ は TSPの τ₀ の 10000倍程度大きい
   ```
   → **正規化が必要:** τ₀ = (B_nn/n) / W_max ≈ 0.001〜0.02

   **方針C: Δτとのバランスを考える**
   - 論文の推奨: τ₀ と Δτ は同じオーダー（両方とも0.001〜0.01程度）
   - 本実装: τ₀=100、Δτ=10〜100 → オーダーは近いが、絶対値が大きすぎる
   - **改善案:** τ₀ と Δτ の両方を正規化し、0.001〜0.01の範囲に収める

4. **min_pheromone=100 の問題**
   - この値により、τ₀の自動計算が完全に無意味になっている
   - **なぜ100なのか？** → 実験的に決定された可能性が高いが、理論的根拠が不明
   - **影響:** フェロモンの絶対値が大きくなり、相対的な差異が見えにくくなる
   - **改善案:** min_pheromoneを撤廃するか、非常に小さい値（0.01など）に設定

---

## 3. 本実装（conventional_aco_solver.py）の検証ポイント

### 3.1 状態遷移規則の実装確認

**チェック項目:**
- [ ] `_select_next_node()` で q₀ = 0.9 を使っているか？
- [ ] q ≤ q₀ の場合、`_select_best_edge()` で確定的選択をしているか？
- [ ] q > q₀ の場合、`_probabilistic_selection()` で確率的選択をしているか？
- [ ] β_bandwidth = 0 の場合、フェロモンのみで選択しているか？
- [ ] β_bandwidth > 0 の場合、τ^α · w^β を計算しているか？

### 3.2 局所更新規則の実装確認

**チェック項目:**
- [ ] `_apply_local_update()` が移動直後に呼ばれているか？
- [ ] 式 `τ_ij ← (1-ξ)τ_ij + ξτ₀` を正しく実装しているか？
- [ ] ξ = 0.1 を使っているか？
- [ ] τ₀ の計算は適切か？（"auto"の場合、B_nn/n を計算）

### 3.3 大域更新規則の実装確認

**チェック項目:**
- [ ] 世代終了後、全エッジを揮発（evaporate）しているか？
- [ ] Global Bestのアリのみがフェロモンを付加しているか？
- [ ] 他のアリはフェロモンを付加していないか？
- [ ] Δτ の計算は適切か？（Q · B_gb を使用）

### 3.4 MBL問題特有の懸念点

**重要な疑問:**

1. **フェロモンのスケーリング問題**
   - TSP: 距離は数百〜数千、τ₀ = 1/(n·L_nn) で非常に小さい（0.001以下）
   - MBL: 帯域は10〜100、τ₀ = B_nn/n で大きい可能性（例: 50/20 = 2.5）
   - **しかし本実装では min_pheromone=100 を設定** → τ₀ ≥ 100
   - **これは論文のスケールと全く異なる！**

2. **フェロモン付加量の妥当性**
   - TSP: Δτ = 1/L_gb（例: 1/1000 = 0.001）
   - MBL: Δτ = Q·B_gb（例: Q=1, B_gb=80 → Δτ=80）
   - **本実装では Q はどこで定義されているか？** → SimplePheromoneUpdater内？

3. **最近傍ヒューリスティック解の定義**
   - TSP: 貪欲法で最近傍都市を順に訪問
   - MBL: `_calculate_nearest_neighbor_heuristic()` で最大帯域のリンクを選択
   - **これは本当に「最近傍」なのか？** → むしろ「貪欲法（greedy）」

---

## 4. 次のステップ

1. **コード詳細確認:**
   - SimplePheromoneUpdater の Q 値を確認
   - config.yaml の全パラメータを確認
   - フェロモンの実際の値の範囲を確認（ログ出力を追加）

2. **実験的検証:**
   - 小さなグラフで手動計算と比較
   - フェロモン値の時系列変化を可視化
   - Global Best以外のアリがフェロモン更新していないか確認

3. **改善案の検討:**
   - τ₀ のスケーリングを論文に合わせるべきか？
   - Δτ の計算式を見直すべきか？
   - Q の値を調整すべきか？

---

## 5. 暫定評価

### ✅ 正しく実装されていると思われる点
- 状態遷移規則（Pseudo-Random-Proportional Rule）の基本構造
- 局所更新のタイミング（移動直後）
- 大域更新の対象（Global Bestのみ）

### ⚠️ 疑問がある点
- フェロモンのスケール（min_pheromone=100は大きすぎないか？）
- τ₀ の計算式（TSPの式をそのまま逆転させただけで妥当か？）
- Δτ の計算式（Q·B_gb のスケールは適切か？）
- 「最近傍ヒューリスティック」の定義（貪欲法との違い）

### ❓ 確認が必要な点
- SimplePheromoneUpdater の実装詳細
- config.yaml の全パラメータ値
- 実際の実行時のフェロモン値の範囲

---

## 6. 実装の検証結果（2026-01-11）

### 6.1 config.yaml の設定値

```yaml
aco:
  q_factor: 1.0              # Q値（フェロモン付加量の係数）
  alpha: 1.0                 # フェロモンの重み（論文推奨値）
  beta_bandwidth: 2.0        # 帯域ヒューリスティックの重み（論文推奨値）
  q0: 0.9                    # Pseudo-Random-Proportional Ruleの確率（論文推奨値）
  local_update_xi: 0.1       # ローカル更新の強度（論文推奨値）
  initial_pheromone: "auto"  # 初期フェロモン値（自動計算）
  evaporation_rate: 0.02     # 揮発率（⚠️論文推奨値0.1より小さい！）
  min_pheromone: 100         # 最小フェロモン値（⚠️論文のスケールと全く異なる！）
  max_pheromone: 1000000000  # 最大フェロモン値（10億、⚠️巨大！）
```

### 6.2 SimplePheromoneUpdater の実装

**場所:** `aco_moo_routing/src/aco_routing/modules/pheromone.py:249-302`

**フェロモン付加量の計算:**
```python
# 評価関数を使用してスコアを計算
score = self.evaluator.evaluate(bandwidth, delay, hops)
# 帯域のみの場合: score = bandwidth
# 遅延制約がある場合: score = bandwidth / delay

# フェロモン付加量 = Q * score
delta_pheromone = self.q_factor * score  # Q=1.0, score=10〜100
```

**結果:**
- 帯域のみの場合: **Δτ = Q × B_k = 1.0 × (10〜100) = 10〜100**
- TSPの場合（参考）: Δτ = 1/L_gb ≈ 0.001〜0.01（総距離が100〜1000の場合）

### 6.3 初期フェロモン τ₀ の計算（"auto"モード）

**場所:** `conventional_aco_solver.py:244-264`

```python
def _calculate_initial_pheromone(self, start_node: int, goal_node: int) -> float:
    n = self.graph.num_nodes  # 例: 100
    b_nn = self._calculate_nearest_neighbor_heuristic(start_node, goal_node)  # 例: 50
    tau_0 = b_nn / n  # 例: 50/100 = 0.5
    # min_pheromone以下にならないように調整
    min_pheromone = self.config["aco"].get("min_pheromone", 100)
    return max(tau_0, min_pheromone)  # 例: max(0.5, 100) = 100
```

**結果:**
- 計算上の τ₀ = B_nn / n ≈ 0.5〜1.0（B_nn=50, n=100の場合）
- **実際の τ₀ = max(0.5, 100) = 100**（min_pheromoneで強制的に100に引き上げられる！）

### 6.4 スケーリング問題の深刻度

| 項目 | TSP（論文オリジナル） | MBL問題（本実装） | 差異 |
|------|----------------------|------------------|------|
| **τ₀** | 1/(n·L_nn) ≈ 0.001 | max(B_nn/n, 100) = **100** | **10万倍** |
| **Δτ** | 1/L_gb ≈ 0.001〜0.01 | Q·B_gb = **10〜100** | **1000〜10000倍** |
| **ρ** | 0.1（論文推奨値） | **0.02** | 1/5（揮発が遅い） |
| **min_pheromone** | 設定なし | **100** | N/A |
| **max_pheromone** | 設定なし | **10億** | N/A |

**分析:**

1. **τ₀が異常に大きい（100）**
   - 論文のTSPでは0.001程度だが、本実装では100（10万倍）
   - これは`min_pheromone=100`によって強制的に引き上げられている
   - 論文の意図（「控えめな初期値」）が完全に失われている

2. **Δτが大きすぎる（10〜100）**
   - 論文のTSPでは0.001〜0.01程度だが、本実装では10〜100（1000〜10000倍）
   - τ₀=100に対してΔτ=10〜100なので、1回のGlobal Best更新でフェロモンが10%〜100%増加
   - これは非常に強い正のフィードバック

3. **揮発率が小さすぎる（0.02）**
   - 論文推奨値は0.1だが、本実装では0.02（1/5）
   - 1世代あたりの減少は2%のみ → フェロモンが蓄積しやすい
   - 強い正のフィードバック（Δτ=10〜100）と組み合わさると、早期収束のリスク

4. **ローカル更新の影響**
   - ローカル更新の式: `τ_ij ← (1-ξ)τ_ij + ξτ₀ = 0.9τ_ij + 0.1×100 = 0.9τ_ij + 10`
   - τ_ij=100の場合: 新値 = 90 + 10 = 100（変化なし）
   - τ_ij=200の場合: 新値 = 180 + 10 = 190（10減少）
   - τ_ij=1000の場合: 新値 = 900 + 10 = 910（90減少）
   - **高フェロモンエッジほど大きく減少するが、τ₀=100への収束が遅い**

### 6.5 実装の信頼性評価

#### ✅ 正しく実装されている点（アルゴリズム構造）

1. **状態遷移規則（Pseudo-Random-Proportional Rule）**
   - q₀=0.9の確率で最良エッジを選択（`_select_best_edge()`）
   - それ以外の確率で確率的選択（`_probabilistic_selection()`）
   - τ^α · η^β の計算式が正しい

2. **ローカル更新のタイミング**
   - 移動直後に`_apply_local_update()`を呼び出している
   - 式: `τ_ij ← (1-ξ)τ_ij + ξτ₀` が正しく実装されている

3. **グローバル更新の対象**
   - 世代終了後、全エッジを揮発（`evaporate()`）
   - Global Bestのアリのみがフェロモンを付加（`update_from_ant()`）
   - 他のアリはフェロモンを付加しない

#### ❌ 論文と大きく異なる点（パラメータスケーリング）

1. **初期フェロモン τ₀ が10万倍大きい**
   - 論文: τ₀ ≈ 0.001（TSPの場合）
   - 本実装: τ₀ = 100（min_pheromoneで強制引き上げ）
   - **影響:** フェロモンの絶対値が異常に大きくなり、相対的な差異が見えにくくなる

2. **フェロモン付加量 Δτ が1000〜10000倍大きい**
   - 論文: Δτ = 1/L_gb ≈ 0.001〜0.01
   - 本実装: Δτ = Q·B_gb = 10〜100
   - **影響:** 1回の更新でフェロモンが大きく増加し、早期収束しやすい

3. **揮発率 ρ が1/5に減少**
   - 論文: ρ = 0.1
   - 本実装: ρ = 0.02
   - **影響:** フェロモンが蓄積しやすく、過去の経験が長く残る

4. **τ₀の計算式が論文と逆方向**
   - 論文（TSP）: τ₀ = 1/(n·L_nn) → 小さい値（抑制）
   - 本実装（MBL）: τ₀ = B_nn/n → 大きい値（増幅）
   - **しかし実際にはmin_pheromone=100で上書きされるため、計算式の意味がない**

---

**結論:**  

**「単純に適用しただけ」という主張は正しくありません。**

アルゴリズムの**構造（状態遷移規則、ローカル更新、グローバル更新）**は忠実に再現されていますが、  
**パラメータのスケーリング**が論文のTSP向けの値と**桁違いに異なります**。

特に、`min_pheromone=100`という設定により、論文の意図（「問題の規模に応じて自動調整される控えめな初期値」）が  
完全に失われています。これは**意図的な改変**であり、「単純に適用しただけ」とは言えません。

**この実装は以下のように解釈すべきです:**
- ACSの**アルゴリズム構造**をMBL問題に適用
- ただし、**パラメータは独自に調整**されており、論文の推奨値とは大きく異なる
- 結果として、**早期収束しやすい設定**になっている可能性が高い
- 「結果が悪く出て欲しい」という期待に反して、**意図的に調整された実装**である

### 6.6 次のステップ（改善案）

1. **論文準拠の実装を作成**
   - min_pheromone を撤廃（または非常に小さい値に設定）
   - τ₀ の計算式を見直す（TSPの式をMBL問題に正しく適用）
   - ρ を0.1に戻す
   - Δτ のスケーリングを調整（正規化など）

2. **現在の実装の意図を確認**
   - なぜ min_pheromone=100 が必要なのか？
   - なぜ evaporation_rate=0.02 なのか？
   - これらのパラメータは実験的に決定されたのか？

3. **実験的検証**
   - 現在のパラメータと論文準拠のパラメータで結果を比較
   - 収束速度、解の品質、探索の多様性を評価

---

## 7. MBL問題へのACS適用の推奨事項（理論的に正しい実装）

### 7.1 基本方針

**「TSPの論文パラメータをそのままMBL問題に適用する」のではなく、  
「ACSのアルゴリズム構造を維持しつつ、MBL問題の特性に合わせてパラメータをスケーリングする」**

### 7.2 推奨パラメータ（論文準拠・スケーリング調整版）

#### **Case 1: 正規化なし（本実装に近い、ただし論文推奨値に修正）**

```yaml
aco:
  # 論文推奨値を維持
  alpha: 1.0
  beta_bandwidth: 2.0
  q0: 0.9
  local_update_xi: 0.1
  evaporation_rate: 0.1  # 論文推奨値に戻す
  
  # スケーリング調整
  q_factor: 0.01  # Δτ = 0.01 × (10〜100) = 0.1〜1.0
  initial_pheromone: "auto"  # τ₀ = (B_nn/n) × 0.01 ≈ 0.005〜0.02
  min_pheromone: 0.01  # 小さい値に変更（論文にはないが、数値安定性のため）
  max_pheromone: 100  # 現実的な上限
```

**Δτのスケーリング:**
```
Δτ = q_factor × B_gb = 0.01 × (10〜100) = 0.1〜1.0
```

**τ₀の自動計算（修正版）:**
```python
def _calculate_initial_pheromone(self, start_node: int, goal_node: int) -> float:
    n = self.graph.num_nodes
    b_nn = self._calculate_nearest_neighbor_heuristic(start_node, goal_node)
    # スケーリング係数を追加
    tau_0 = (b_nn / n) * self.q_factor  # 例: (50/100) × 0.01 = 0.005
    min_pheromone = self.config["aco"].get("min_pheromone", 0.01)
    return max(tau_0, min_pheromone)  # 例: max(0.005, 0.01) = 0.01
```

#### **Case 2: 完全正規化版（TSPとのスケール一致を重視）**

```yaml
aco:
  # 論文推奨値を維持
  alpha: 1.0
  beta_bandwidth: 2.0
  q0: 0.9
  local_update_xi: 0.1
  evaporation_rate: 0.1
  
  # 正規化パラメータ
  q_factor: 0.001  # TSPのスケールに合わせる
  initial_pheromone: "auto"  # τ₀ = (B_nn/n) × 0.001 ≈ 0.0005〜0.002
  min_pheromone: 0.0001  # TSPのスケールに合わせる
  max_pheromone: 1.0  # TSPのスケールに合わせる
```

**Δτのスケーリング:**
```
Δτ = q_factor × B_gb = 0.001 × (10〜100) = 0.01〜0.1
```
→ TSPの Δτ = 0.001〜0.01 と同じオーダー

#### **Case 3: 帯域範囲で正規化（0〜1スケール）**

```python
# SimplePheromoneUpdater の修正版
def update_from_ant(self, ant: Ant, graph: RoutingGraph) -> None:
    bandwidth, delay, hops = ant.get_solution()
    
    # 帯域を正規化（0〜1の範囲に変換）
    W_min = self.config["graph"]["bandwidth_range"][0]  # 10
    W_max = self.config["graph"]["bandwidth_range"][1]  # 100
    normalized_bandwidth = (bandwidth - W_min) / (W_max - W_min)  # 0〜1
    
    # フェロモン付加量（正規化後）
    delta_pheromone = self.q_factor * normalized_bandwidth  # 0〜q_factor
    
    # 経路上の各エッジにフェロモンを付加
    route_edges = ant.get_route_edges()
    for u, v in route_edges:
        graph.update_pheromone(u, v, delta_pheromone, bidirectional=True)
```

```yaml
aco:
  q_factor: 0.01  # Δτ = 0.01 × (0〜1) = 0〜0.01
  initial_pheromone: 0.001  # 固定値（正規化後）
  min_pheromone: 0.0001
  max_pheromone: 0.1
```

### 7.3 各Caseの比較

| Case | τ₀ | Δτ | 特徴 | 推奨度 |
|------|----|----|------|-------|
| **本実装** | 100 | 10〜100 | フェロモンが大きすぎる、早期収束しやすい | ❌ |
| **Case 1** | 0.005〜0.02 | 0.1〜1.0 | 本実装を改善、スケールを小さくした | ⭐⭐⭐ |
| **Case 2** | 0.0005〜0.002 | 0.01〜0.1 | TSPのスケールに完全一致 | ⭐⭐⭐⭐⭐ |
| **Case 3** | 0.001 | 0〜0.01 | 正規化により直感的、実装が複雑 | ⭐⭐⭐⭐ |

### 7.4 最終推奨

**「Case 2: 完全正規化版」を推奨します。**

**理由:**
1. TSPの論文パラメータとスケールが一致する → 論文の意図を忠実に再現
2. τ₀ と Δτ が同じオーダー（0.001〜0.01） → バランスが良い
3. 揮発率 ρ=0.1 を使用 → 論文推奨値
4. 早期収束を防ぎ、探索の多様性を維持できる

**実装の修正箇所:**
1. `config.yaml`: `q_factor=0.001`, `evaporation_rate=0.1`, `min_pheromone=0.0001`
2. `conventional_aco_solver.py`: `_calculate_initial_pheromone()` でスケーリング係数を追加
3. （オプション）`SimplePheromoneUpdater`: 帯域範囲で正規化（Case 3）

---

## 8. まとめ: 「単純に適用しただけ」なのか？

### 検証結果

| 観点 | 評価 | 詳細 |
|------|------|------|
| **アルゴリズム構造** | ✅ 忠実に再現 | 状態遷移規則、ローカル更新、グローバル更新の構造は正しい |
| **論文推奨パラメータ** | ⚠️ 一部のみ使用 | α, β, q₀, ξ は論文推奨値だが、ρ は異なる |
| **スケーリング** | ❌ 全く異なる | τ₀, Δτ が論文の1000〜10000倍大きい |
| **min_pheromone** | ❌ 独自の改変 | 論文にはない設定で、τ₀の自動計算を無意味にしている |
| **理論的妥当性** | ⚠️ 不明確 | τ₀ と Δτ の計算式がMBL問題に適しているか疑問 |

### 結論

**「ACSのアルゴリズム構造を忠実に再現しているが、パラメータは独自に調整されており、論文の『単純な適用』とは言えない」**

特に、`min_pheromone=100`という設定は、論文の意図（「控えめな初期値から学習で強化」）を完全に失わせており、  
**意図的な改変**と見なすべきです。

「結果が悪く出て欲しい」という期待に対しては、**現在の実装は早期収束しやすい設定になっているため、  
むしろ良い結果が出る可能性があります**（ただし、探索の多様性は犠牲になる）。

**真に「単純に適用しただけ」の従来手法を実装するには、Case 2（完全正規化版）を推奨します。**

---

## 9. MBL問題への正しい適用方法（理論的解釈の確立）

### 9.1 TSPからMBLへの頭の切り替え

| 観点 | TSP（距離の最小化） | MBL（ボトルネック帯域の最大化） |
|------|-------------------|-------------------------------|
| **目的** | 総距離を最小化 | ボトルネック帯域を最大化 |
| **評価方法** | 足し算（総和） | 最小値（Min） |
| **良い値** | 小さい距離 | 大きい帯域 |
| **ヒューリスティック** | 1/d_ij（距離の逆数） | w_ij（帯域そのもの） |

**重要:** TSPは「足し算（総和）」で評価しますが、MBLは「最小値（Min）」で評価します。  
この違いがフェロモン更新のスケーリングに大きく影響します。

### 9.2 数値の正規化（Scaling）の必要性

**問題:** 帯域幅が `10〜100` Mbps という生の値をそのまま使うと、フェロモン値 τ とのバランス調整が困難

**解決策:** 最大帯域幅 W_max = 100 Mbps で割って、**0〜1の範囲に正規化**

```
生の帯域幅: w_ij ∈ [10, 100] Mbps
正規化後:   w̃_ij = w_ij / W_max ∈ [0.1, 1.0]
```

**正規化の利点:**
1. フェロモンとヒューリスティックのバランスが取りやすい
2. パラメータ（α, β, ρ, τ₀）の設定が直感的になる
3. 数値計算が安定する（オーバーフロー/アンダーフローを防ぐ）

---

### 9.3 MBL問題における各変数の解釈

#### A. 目的関数（蟻の成績表）: S_k

**定義:**
```
S_k = min{w̃_ij : (i,j) ∈ P_k}
```
- P_k: 蟻 k が通った経路
- w̃_ij: エッジ (i,j) の正規化後の帯域幅

**具体例:**
```
経路: 100 Mbps → 50 Mbps → 30 Mbps → 80 Mbps
正規化: 1.0 → 0.5 → 0.3 → 0.8
スコア S_k = min{1.0, 0.5, 0.3, 0.8} = 0.3
```

**TSPとの違い:**
- TSP: L_k = Σ d_ij（足し算）
- MBL: S_k = min{w̃_ij}（最小値）

**重要な帰結:** 
- TSPでは経路が長いほどL_kが大きくなる（ホップ数の影響）
- MBLではホップ数は無関係、ボトルネックとなる1本のエッジで決まる

---

#### B. ヒューリスティック情報: η_ij

**定義:**
```
η_ij = w̃_ij = w_ij / W_max
```

**意味:** 
「目の前のこの道は、直感的に良い道か？」  
→ 帯域が太いほど、将来的にボトルネックにならない可能性が高い

**TSPとの違い:**
- TSP: η_ij = 1/d_ij（距離の逆数、逆転変換が必要）
- MBL: η_ij = w̃_ij（帯域そのもの、逆転変換不要）

**理由:** 両方とも「大きい方が良い」に統一されている
- TSP: 距離が短い → 1/d_ij が大きい → 良い
- MBL: 帯域が広い → w̃_ij が大きい → 良い

---

#### C. フェロモン初期値: τ₀

**推奨値:**
```
τ₀ = 1.0  （正規化後の理論最大値）
```

**理由: 楽観的初期化（Optimistic Initialization）**
- 未探索のエッジは「最大帯域（100 Mbps = 1.0）である可能性がある」と楽観的に見なす
- これにより、初期段階での探索を促進する
- ACSの局所更新は `τ_ij ← (1-ξ)τ_ij + ξτ₀` という式で、フェロモンを τ₀ に近づける
- τ₀ = 1.0 なら、訪問したエッジは徐々に 1.0 に収束していく

**TSPとの違い:**
- TSP: τ₀ = 1/(n·L_nn) ≈ 0.001（控えめな初期値）
- MBL: τ₀ = 1.0（楽観的な初期値）

**なぜ違うのか？**
- TSPのローカル更新: 訪問したエッジのフェロモンを**減らす**（探索の多様性）
  - τ₀ が小さい → 訪問済みエッジは小さい値に収束 → 他のアリは別の道を選ぶ
- MBLのローカル更新: 同じ式だが、解釈が異なる
  - τ₀ = 1.0（最大値） → 訪問済みエッジは 1.0 に近づく → **むしろ増える**？
  
**⚠️ 重要な疑問（要確認）:**
- もし初期値が τ₀ = 1.0 で、ローカル更新で τ₀ に近づけるなら、フェロモンが増える？
- それとも、グローバル更新で大きく増やすので、ローカル更新による 1.0 への収束は相対的に「減少」と見なせる？
- 後ほどユーザーに確認が必要

---

#### D. フェロモン付加量（報酬）: Δτ

**大域的更新（Global Updating Rule）での付加量:**

```
Δτ_ij = B_gb^norm
```
- B_gb^norm: Global Best経路のボトルネック帯域（正規化後）

**具体例:**
```
Global Bestのボトルネック帯域: 80 Mbps
正規化: 80 / 100 = 0.8
報酬: Δτ = 0.8
```

**解釈:**
「このルートを使ったら、最低でも 80 Mbps は確保できたぞ！」という情報をフェロモンとして残す。

**悪い経路の場合:**
```
ボトルネック帯域: 10 Mbps
正規化: 10 / 100 = 0.1
報酬: Δτ = 0.1（弱い強化）
```

**TSPとの対応:**
- TSP: Δτ = 1/L_gb（短い経路ほど大きい報酬、0.001〜0.01）
- MBL: Δτ = B_gb^norm（広い帯域ほど大きい報酬、0.1〜1.0）

**スケールの比較:**
- TSP: Δτ ∈ [0.001, 0.01]（非常に小さい）
- MBL: Δτ ∈ [0.1, 1.0]（0〜1の範囲）

**⚠️ 重要:** 正規化により、Δτとτはほぼ同じスケール（0〜1）になる！

---

#### E. 局所的更新（ローカル更新）: τ_ij ← (1-ξ)τ_ij + ξτ₀

**式（変更なし）:**
```
τ_ij ← (1-ξ)τ_ij + ξτ₀
ξ = 0.1（論文推奨値）
τ₀ = 1.0（MBL問題）
```

**具体例:**
```
現在のフェロモン: τ_ij = 0.5
更新後: τ_ij = 0.9 × 0.5 + 0.1 × 1.0 = 0.45 + 0.1 = 0.55
```

**解釈:**
「ここは私が通ったから、他の蟻は別の道（まだ試していない道）を探してくれ」

**⚠️ 疑問点:**
- τ₀ = 1.0 の場合、0.5 → 0.55 と**増えている**
- これは「踏み荒らし」ではなく「踏み固め」では？
- TSP（τ₀ = 0.001）の場合: 0.5 → 0.45 と減る

**可能な解釈（要確認）:**
1. **解釈A:** MBL問題では、τ₀ < 初期値 に設定する必要がある？
   - 例: τ₀ = 0.1（悲観的初期化）で、訪問済みエッジは 0.1 に近づく
2. **解釈B:** 初期フェロモンは τ₀ より大きい値（例: 10.0）に設定し、訪問で 1.0 に減少させる？
3. **解釈C:** グローバル更新で Δτ=0.8 などの大きな値が加わるので、1.0 への収束は相対的に「減少」

---

### 9.4 β（ヒューリスティック重要度）の設定

**推奨値:**
```
β = 2〜5（高めに設定）
```

**理由: 細い回線を徹底的に避ける**

**具体例（β=2の場合）:**
```
10 Mbps のエッジ: η = 0.1, η^β = 0.01
100 Mbps のエッジ: η = 1.0, η^β = 1.0

確率の重み比: 1.0 / 0.01 = 100倍
```

**具体例（β=5の場合）:**
```
10 Mbps のエッジ: η = 0.1, η^β = 0.00001
100 Mbps のエッジ: η = 1.0, η^β = 1.0

確率の重み比: 1.0 / 0.00001 = 100000倍
```

**MBL問題の特性:**
- 「10 Mbps を選んだ時点で負け」（ボトルネックが決まる）
- したがって、β を高めに設定して、太い回線を**圧倒的に**優先させる

**TSPとの違い:**
- TSP: β = 2（論文推奨値、距離の差は累積的）
- MBL: β = 2〜5（高めに設定、ボトルネックは1本で決まるため）

---

### 9.5 MBL適用のための設定まとめ

| 項目 | 設定値・式 | 意図 |
|------|-----------|------|
| **帯域幅の扱い** | w̃_ij = w_ij / W_max | 0〜1に正規化し計算を安定させる |
| **ヒューリスティック η** | η_ij = w̃_ij | 太い回線を直感的に選ばせる |
| **評価関数 S_k** | S_k = min{w̃_ij} | 経路中の最小帯域（ボトルネック）をスコアとする |
| **フェロモン初期値 τ₀** | τ₀ = 1.0 | 未探索領域への楽観的期待値 |
| **報酬 Δτ** | Δτ = B_gb^norm | ベストパスのボトルネック値（正規化後）で強化 |
| **探索パラメータ β** | β = 2〜5 | 細い回線を徹底的に避けるため強めに設定 |
| **α（フェロモン重要度）** | α = 1.0 | 論文推奨値を維持 |
| **q₀（exploitation確率）** | q₀ = 0.9 | 論文推奨値を維持 |
| **ξ（ローカル更新強度）** | ξ = 0.1 | 論文推奨値を維持 |
| **ρ（揮発率）** | ρ = 0.1 | 論文推奨値を維持 |

---

### 9.6 アルゴリズム全体の流れ（MBL問題版）

1. **初期化**
   - 全エッジに τ₀ = 1.0 をセット
   - 帯域幅を正規化: w̃_ij = w_ij / W_max

2. **各世代のループ**
   
   a. **各蟻の移動（解構築）**
   - 確率 q₀ で最良エッジ選択: argmax_j {τ_ij^α · w̃_ij^β}
   - 確率 (1-q₀) で確率的選択: p_ij ∝ τ_ij^α · w̃_ij^β
   - **移動直後にローカル更新:** τ_ij ← (1-ξ)τ_ij + ξτ₀
   
   b. **ゴール到達**
   - 各蟻のスコア S_k = min{w̃_ij} を計算
   - Global Best更新: S_gb = max{S_k}
   
   c. **グローバル更新（世代終了後）**
   - **全エッジを揮発:** τ_ij ← (1-ρ)τ_ij
   - **Global Bestの経路のみ付加:** τ_ij ← τ_ij + ρ·B_gb^norm

3. **終了条件まで繰り返し**

---

### 9.7 残された疑問点（要確認事項）

#### **疑問1: ローカル更新の解釈**

τ₀ = 1.0、初期フェロモン = 1.0 の場合、ローカル更新で τ_ij が増減しない？

**シナリオA（初期値 = τ₀ = 1.0）:**
```
初期: τ_ij = 1.0
訪問後: τ_ij = 0.9 × 1.0 + 0.1 × 1.0 = 1.0（変化なし）
```
→ ローカル更新の意味が失われる

**シナリオB（初期値 > τ₀）:**
```
初期: τ_ij = 10.0（大きい値で初期化）
訪問後: τ_ij = 0.9 × 10.0 + 0.1 × 1.0 = 9.1（減少）
```
→ ローカル更新で減少する（TSPと同じ効果）

**シナリオC（グローバル更新後の状態）:**
```
グローバル更新後: τ_ij = 5.0（フェロモンが蓄積）
訪問後: τ_ij = 0.9 × 5.0 + 0.1 × 1.0 = 4.6（減少）
```
→ 蓄積したフェロモンに対しては減少効果がある

**→ ユーザーに確認: 初期フェロモン値はτ₀と同じか、それとも別の値か？**

---

#### **疑問2: 揮発率 ρ の設定**

論文推奨値は ρ = 0.1 ですが、MBL問題でも同じで良いか？

**考慮点:**
- TSP: Δτ ≈ 0.001〜0.01、揮発 = 10%
- MBL: Δτ ≈ 0.1〜1.0、揮発 = 10%

正規化後のスケールは似ているので、ρ = 0.1 で妥当と思われる。

---

### 9.8 次のステップ

疑問点をユーザーに確認した後、以下を実施：

1. **設計の確定**
   - 初期フェロモン値の設定方針を決定
   - ローカル更新の動作を確認
   
2. **実装計画の策定**（次のフェーズ: 3. 実装し直す）
   - conventional_aco_solver.py の修正箇所を特定
   - SimplePheromoneUpdater の修正内容を決定
   - config.yaml の推奨パラメータを確定
   
3. **実装と検証**
   - 論文準拠の従来手法を実装
   - 小さなグラフで動作確認
   - 既存実装との比較

