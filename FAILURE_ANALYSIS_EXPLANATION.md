# 探索失敗の種類と分析方法の説明

## 1. 探索失敗の種類

### 1.1 通常の探索失敗（TTL、ループ）

#### TTL到達（生存時間超過）
- **発生条件**: アリが最大ステップ数（TTL=100）に達したが、ゴールに到達できなかった
- **コード位置**: `aco_solver.py` 509-513行目
```python
if not ant.is_alive():
    active_ants.remove(ant)
    ant_log_unique_optimal.append(-1)  # -1 = ゴール未到達
    ant_log_any_optimal.append(-1)  # -1 = ゴール未到達
```
- **ログ値**: `-1`

#### 行き先がない（ループ/デッドエンド）
- **発生条件**: 全ての隣接ノードを訪問済みで、次のノードを選択できない
- **コード位置**: `aco_solver.py` 521-526行目
```python
if next_node is None:
    # 行き先がない場合（全ての隣接ノードを訪問済み）は探索失敗
    active_ants.remove(ant)
    ant_log_unique_optimal.append(-1)  # -1 = ゴール未到達
    ant_log_any_optimal.append(-1)  # -1 = ゴール未到達
```
- **ログ値**: `-1`

### 1.2 遅延制約における探索失敗

#### 移動前の制約チェック失敗
- **発生条件**: 次のノードに移動する前に、累積遅延 + エッジ遅延が制約値を超える
- **コード位置**: `aco_solver.py` 535-546行目
```python
if self.delay_constraint_enabled:
    estimated_delay = ant.total_delay + edge_attr["delay"]
    if estimated_delay > self.max_delay:
        # 制約を満たさない場合は探索失敗
        active_ants.remove(ant)
        ant_log_unique_optimal.append(-1)  # -1 = ゴール未到達（制約違反）
        ant_log_any_optimal.append(-1)  # -1 = ゴール未到達（制約違反）
```
- **ログ値**: `-1`
- **特徴**: この時点で探索を中断し、フェロモンは付加されない

#### ゴール到達時の制約チェック失敗
- **発生条件**: ゴールに到達したが、経路の累積遅延が制約値を超えている
- **コード位置**: `aco_solver.py` 563-573行目
```python
if self.delay_constraint_enabled:
    if solution_delay > self.max_delay:
        # 制約違反の場合は探索失敗として扱う
        active_ants.remove(ant)
        ant_log_unique_optimal.append(-1)  # -1 = ゴール未到達（制約違反）
        ant_log_any_optimal.append(-1)  # -1 = ゴール未到達（制約違反）
```
- **ログ値**: `-1`
- **特徴**: ゴールに到達しているが、制約違反のためフェロモンは付加されない

### 1.3 成功ケース

#### 最適解発見
- **Any Optimal**: 最大ボトルネック帯域幅を達成し、遅延制約を満たす経路のいずれかに到達
- **Unique Optimal**: 最大ボトルネック帯域幅を達成し、かつ最小遅延を持つ経路に到達
- **ログ値**: `0`

#### ゴール到達（非最適解）
- **発生条件**: ゴールに到達し、制約を満たしているが、最適解ではない
- **コード位置**: `aco_solver.py` 608行目、633行目
```python
log_value_any = 0 if is_any_optimal else -2
log_value_unique = 0 if is_unique_optimal else -2
```
- **ログ値**: `-2`（ただし、遅延制約が有効な場合は `-2` は使用されない）

---

## 2. 分析のされ方

### 2.1 ログ値の意味

| ログ値 | 意味 | CSVへの記録 | 成功率への影響 |
|--------|------|-------------|---------------|
| `0` | 最適解発見（成功） | **記録される** | **成功としてカウント** |
| `-1` | ゴール未到達（失敗） | **記録される** | **成功率の計算では無視される**（分母にも分子にも含まれない） |
| `-2` | ゴール到達したが最適解ではない | **記録される** | **成功率の計算では無視される**（分母にも分子にも含まれない） |

**重要な点**: `-1`や`-2`は**CSVファイルに記録されます**が、**成功率の計算では無視されます**。これは「1世代で10匹のアリのうち、少なくとも1匹が成功すれば、その世代は成功」という定義によるものです。

### 2.2 成功率の計算方法

`compare_delay_constraint_proposed.py` の `process_csv_data` 関数（108行目）では：

```python
# その世代のチャンク内に最適解（0以上）が一つでもあれば、
# そのシミュレーションはその世代で成功と見なす
if any(idx >= 0 for idx in generation_chunk):
    generation_success_count += 1
```

**重要な点**:
- **成功判定**: `idx >= 0` の場合のみ成功とカウント
- **失敗の扱い**: `-1` や `-2` は**無視される**（分母にも分子にも含まれない）

### 2.3 成功率の計算式

```
成功率 = (成功したシミュレーション数) / (全シミュレーション数) × 100
```

**注意**: 分母は「全シミュレーション数」であり、「全アリ数」ではありません。

**具体例**:
- 1世代に10匹のアリが存在
- CSVファイルには `[0, 0, 0, 0, 0, -1, -1, -1, -1, -1]` が記録される（5匹が成功、5匹が失敗）
- **分析結果**: この世代は「成功」とカウントされる（10匹中1匹でも成功していれば成功）
- **成功率**: 100シミュレーション中、この世代で成功したシミュレーションの割合

**重要な点**: `-1`は**CSVファイルに記録されます**が、成功率の計算では「その世代で少なくとも1匹が成功したかどうか」のみを判定するため、失敗の数は影響しません。

---

## 3. 失敗が成功率に与える影響

### 3.1 現在の分析方法の説明

#### 失敗の記録と分析での扱い

現在の分析方法では：
- **成功**: `idx >= 0` → CSVに記録され、分子にカウント
- **失敗**: `idx < 0` → **CSVに記録されるが、成功率の計算では無視される**（分母にも分子にも含まれない）

これは、**「1世代で10匹のアリのうち、少なくとも1匹が成功すれば、その世代は成功」**という定義に基づいています。

**重要な点**: 
- `-1`は**CSVファイルに記録されます**（実際のCSVファイルを確認すると、`-1,-1`が多数記録されています）
- しかし、**成功率の計算では無視されます**（「1世代で10匹のアリのうち、少なくとも1匹が成功すれば、その世代は成功」という定義による）

#### 問題2: 失敗の種類が区別されない

- TTL到達（`-1`）
- ループ/デッドエンド（`-1`）
- 遅延制約違反（移動前）（`-1`）
- 遅延制約違反（ゴール到達時）（`-1`）

これらはすべて `-1` として記録され、分析では区別されません。

### 3.2 「失敗が成功率に影響せずに有利になっていないか」という懸念について

#### 現在の実装では問題ありません

理由：

1. **成功率の定義が明確**
   - 「1世代で10匹のアリのうち、少なくとも1匹が成功すれば、その世代は成功」
   - これは、**探索の多様性を考慮した定義**であり、1匹でも成功すれば良いという意味です

2. **失敗は「不利」として機能している**
   - 失敗したアリ（`-1`）は、フェロモンを付加しないため、**その経路への探索が抑制**されます
   - これにより、失敗は間接的に成功率に影響を与えます（良い経路への集中を促進）

3. **制約違反の失敗は「自然な選択圧」として機能**
   - 遅延制約を満たさない経路にはフェロモンが付加されないため、**制約を満たす経路への探索が促進**されます
   - これは、制約が「探索のガイド」として機能していることを示しています

#### ただし、より詳細な分析が必要な場合

もし、**失敗の種類を区別して分析したい場合**は、以下のような改善が考えられます：

1. **失敗の種類を区別するログ値**
   - `-1`: TTL到達
   - `-2`: ループ/デッドエンド
   - `-3`: 遅延制約違反（移動前）
   - `-4`: 遅延制約違反（ゴール到達時）

2. **失敗率の分析**
   - 各世代で、失敗したアリの割合を計算
   - 制約条件ごとの失敗率を比較

3. **成功率の再定義**
   - 「1世代で10匹のアリのうち、X匹以上が成功すれば、その世代は成功」
   - または、「1世代で10匹のアリのうち、成功したアリの割合がY%以上であれば、その世代は成功」

---

## 4. 現在の分析方法の妥当性

### 4.1 現在の定義の妥当性

現在の分析方法は、**「探索の多様性を考慮した定義」**として妥当です：

- **理由1**: ACOは確率的アルゴリズムであり、1匹でも最適解を発見できれば、その情報が他のアリに伝播します
- **理由2**: 完全分散方式では、アリがゴールに到達した時点で即座にフェロモンを更新するため、1匹の成功が即座に他のアリの探索に影響を与えます
- **理由3**: この定義は、既存の研究（`aco_sim_caching_model_eval.py`）と一致しています

### 4.2 制約違反の失敗が「有利」になっているか？

**結論: なっていません**

理由：

1. **制約違反経路にはフェロモンが付加されない**
   - これにより、制約違反経路への探索が抑制されます
   - 結果として、制約を満たす経路への探索が促進されます

2. **失敗は「不利」として機能している**
   - 失敗したアリは、フェロモンを付加しないため、その経路への探索が抑制されます
   - これにより、良い経路への集中が促進されます

3. **制約が厳しいほど、探索空間が縮小される**
   - 5.0 msの制約では、探索可能な経路が大幅に減少します
   - これにより、フェロモンが有効な経路に集中し、高い収束率（100%）を実現します

### 4.3 より厳密な分析が必要な場合

もし、**失敗の種類を区別して分析したい場合**は、以下のような改善を検討できます：

1. **ログ値の拡張**
   - 失敗の種類を区別するログ値を追加

2. **失敗率の分析**
   - 各世代で、失敗したアリの割合を計算
   - 制約条件ごとの失敗率を比較

3. **成功率の再定義**
   - 「1世代で10匹のアリのうち、成功したアリの割合がX%以上であれば、その世代は成功」

---

## 5. まとめ

### 5.1 現在の分析方法

- **成功判定**: `idx >= 0` の場合のみ成功とカウント
- **失敗の記録**: `-1` や `-2` は**CSVファイルに記録される**
- **失敗の扱い**: `-1` や `-2` は**成功率の計算では無視される**（分母にも分子にも含まれない）
- **成功率の定義**: 「1世代で10匹のアリのうち、少なくとも1匹が成功すれば、その世代は成功」

**重要な点**: TTL到達などの失敗は**CSVファイルに記録されます**が、成功率の計算では「その世代で少なくとも1匹が成功したかどうか」のみを判定するため、失敗の数は影響しません。

### 5.2 失敗が成功率に与える影響

- **直接的な影響**: 失敗は成功率の計算に含まれない（分母にも分子にも含まれない）
- **間接的な影響**: 失敗したアリはフェロモンを付加しないため、その経路への探索が抑制され、良い経路への集中が促進される

### 5.3 結論

現在の分析方法は、**「探索の多様性を考慮した定義」**として妥当であり、失敗が「有利」になっているわけではありません。むしろ、失敗は「不利」として機能し、良い経路への集中を促進しています。

ただし、より詳細な分析が必要な場合は、失敗の種類を区別するログ値の追加や、失敗率の分析を検討することができます。

